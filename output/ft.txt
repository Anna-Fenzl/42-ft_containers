
[33;5;81m <<<<<<<<<<<<<<<<<<< LEXICOGRAPHICAL_COMPARE >>>>>>>>>>>>>>>>>>>>>>>[0m
true if the first range is lexicographically less than the second, otherwise false

Comparing foo (abc) and bar (abc):	false

Comparing foo (ab) and bar (abc):	true

Comparing foo (aXc) and bar (abc):	true

[33;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<< EQUAL >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
true if the range [first1, last1) is equal to the range [first2, first2 + (last1 - first1)), otherwise false

Comparing foo "~<string>~~~~" and bar ".......<string>":	false

Comparing foo "<string>" and bar "<string>":			true

[33;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< PAIR >>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
pair is a class template that provides a way to store two heterogeneous objects as a single unit

testing with string and double:

The price of lightbulbs is $0.99
The price of shoes is $39.9
The price of tomatoes is $2.3

[38;5;81m ----------------------------------------------------------------------
|                             VECTOR                                 |
----------------------------------------------------------------------
[0m
[38;5;81m 
<<<<<<<<<<<<<<<<<<<<<<<<< CONSTRUCTORS >>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> EMPTY VECTOR:[0m

------------------------------------------------------------------
[0;1m--> FILL VECTOR:[0m
FILL[0] = X, FILL[1] = X, FILL[2] = X, FILL[3] = X, FILL[4] = X, 
------------------------------------------------------------------
[0;1m--> RANGE VECTOR:	(fill.begin()+1, fill.end())[0m
RANGE[0] = X, RANGE[1] = X, RANGE[2] = X, RANGE[3] = X, 
------------------------------------------------------------------
[0;1m--> COPIED VECTOR:	(from fill)[0m
COPY[0] = X, COPY[1] = X, COPY[2] = X, COPY[3] = X, COPY[4] = X, 

[38;5;81m 
<<<<<<<<<<<<<<<<<<<<<<<<<<< ITERATORS >>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1mNO ITERATOR:[0m
for ( INT I = 0; I < SIZE; I++ ) :
0, 1, 2, 3, 4, 

[0;1mINCREMENT ITERATOR:[0m
for ( it = VEC.BEGIN(); it != VEC.END(); ++IT ) :
0, 1, 2, 3, 4, 

[0;1mDECREMENT ITERATOR:[0m
for ( it = --VEC.END(); it != --VEC.BEGIN(); --IT ) :
4, 3, 2, 1, 0, 

[0;1mINCREMENT REVERSE ITERATOR:[0m
for ( it = VEC.RBEGIN(); it != VEC.REND(); ++IT ) :
4, 3, 2, 1, 0, 

[0;1mDECREMENT REVERSE ITERATOR:[0m
for ( it = VEC.REND(); it != VEC.RBEGIN(); --IT ) :
0, 1, 2, 3, 4, 

[0;1m[] OPERATOR:				(forward iterator))[0m
it(vec.begin());       print it[3]: '3'
it(&vec[1]);           print it[3]: '4'

[0;1m[] OPERATOR:				(reverse iterator))[0m
it(vec.rbegin());       print it[3]: '1'
it(&vec[1]);           print it[3]: '0'


[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<<< CAPACITY >>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
D[0] = '!', D[1] = '!', D[2] = '!', D[3] = '!', D[4] = '!', 
size()     = 5
max_size() = 18446744073709551615
capacity() = 5
empty()    = false

------------------------------------------------------------------
[0;1m--> EMPTY VECTOR:
[0m
size()     = 0
max_size() = 18446744073709551615
capacity() = 0
empty()    = true

------------------------------------------------------------------
[0;1m--> RESIZE VECTOR:				
[0m
> resize to smaller size (2)
size()     = 2
capacity() = 5
RES[0] = '!', RES[1] = '!', 

> resize to bigger size 9, 'X')
size()     = 9
capacity() = 10
RES[0] = '!', RES[1] = '!', RES[2] = 'X', RES[3] = 'X', RES[4] = 'X', RES[5] = 'X', RES[6] = 'X', RES[7] = 'X', RES[8] = 'X', 

------------------------------------------------------------------
[0;1m--> RESERVE VECTOR:				(throws when requested capacity > max_size())
[0m
reserving 1000 for DEFAULT
size()     = 5
capacity() = 1000
RES[0] = '!', RES[1] = '!', RES[2] = '!', RES[3] = '!', RES[4] = '!', 

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<< ELEMENT ACCESS >>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
DEF[0] = "DEFAULT STRING"
DEF[1] = "DEFAULT STRING"
DEF[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> []OPERATOR:				(undefined behavior when out of bounds)
[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = "non default, used: mod[i]"
MOD[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .AT():				(throws when out of bounds)
[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = "non default, used: mod.at(i)"
MOD[2] = "DEFAULT STRING"

CATCHED EXCEPTION: ft::vector

------------------------------------------------------------------
[0;1m--> .FRONT():				(undefined behavior when out of bounds)
[0m
MOD[0] == MOD.FRONT() is true
MOD[1] == MOD.FRONT() is false

------------------------------------------------------------------
[0;1m--> .BACK():				(undefined behavior when out of bounds)
[0m
MOD[2] == MOD.BACK() is true
MOD[1] == MOD.BACK() is false

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<< MODIFIERS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
DEF[0] = "DEFAULT STRING"
DEF[1] = "DEFAULT STRING"
DEF[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .CLEAR():[0m

------------------------------------------------------------------
[0;1m--> .ASSIGN(4, "assigned string"):			(fill version)[0m
FILL[0] = "assigned string (fill)"
FILL[1] = "assigned string (fill)"
FILL[2] = "assigned string (fill)"
FILL[3] = "assigned string (fill)"

------------------------------------------------------------------
[0;1m--> .ASSIGN(as.begin()+1, as.end()):			(range version)[0m
RANGE[0] = "DEFAULT STRING"
RANGE[1] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .PUSH_BACK("pushed string"):[0m
PUSH[0] = "DEFAULT STRING"
PUSH[1] = "DEFAULT STRING"
PUSH[2] = "DEFAULT STRING"
PUSH[3] = "pushed string"
PUSH[4] = "another pushed string"

------------------------------------------------------------------
[0;1m--> .POP_BACK():[0m
POP[0] = "DEFAULT STRING"
POP[1] = "DEFAULT STRING"
POP[2] = "DEFAULT STRING"
POP[3] = "pushed string"

------------------------------------------------------------------
[0;1m--> OTHER VECTOR:[0m
OTH[0] = "Other stuff"
OTH[1] = "Other stuff"

------------------------------------------------------------------
[0;1m--> .INSERT( .BEGIN()+1, "->inserted string"):				(one element)[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = " ------ inserted string"
MOD[2] = "DEFAULT STRING"
MOD[3] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .INSERT( .BEGIN(), 5,"->inserted string"):				(multible elements)[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = " ------ inserted string"
MOD[2] = " ------ inserted string"
MOD[3] = " ------ inserted string"
MOD[4] = " ------ inserted string"
MOD[5] = " ------ inserted string"
MOD[6] = "DEFAULT STRING"
MOD[7] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .INSERT(BEGIN()+1, OTHER.BEGIN(), OTHER.END()):			(range)[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = "Other stuff"
MOD[2] = "Other stuff"
MOD[3] = "DEFAULT STRING"
MOD[4] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .ERASE(ERASE.BEGIN()+1)(from vector above):				(single element)[0m
returned iterator is "Other stuff"

MOD[0] = "DEFAULT STRING"
MOD[1] = "Other stuff"
MOD[2] = "DEFAULT STRING"
MOD[3] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .ERASE(ERASE.BEGIN()+2, ERASE.END()-1)(from same vector):			(range)[0m
returned iterator is "DEFAULT STRING"

MOD[0] = "DEFAULT STRING"
MOD[1] = "Other stuff"
MOD[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .SWAP():				(swapping default && other)[0m
DEFAULT:
	DEF[0] = "Other stuff"
	DEF[1] = "Other stuff"
OTHER:
	OTH[0] = "DEFAULT STRING"
	OTH[1] = "DEFAULT STRING"
	OTH[2] = "DEFAULT STRING"

------------------------------------------------------------------

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<< NON-MEMBER FUNCTIONS >>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
DEF[0] = 'a', DEF[1] = 'b', DEF[2] = 'c', DEF[3] = 'd', DEF[4] = 'e', DEF[5] = 'f', 

[0;1m--> OTHER VECTOR:[0m
OTH[0] = 'a', OTH[1] = 'b', 

------------------------------------------------------------------
[0;1m--> OPERATOR==()[0m
DEF == DEF	-> true
DEF == OTH	-> false

------------------------------------------------------------------
[0;1m--> OPERATOR!=()[0m
DEF != DEF	-> false
DEF != OTH	-> true

------------------------------------------------------------------
[0;1m--> OPERATOR<[0m
DEF < DEF	-> false
DEF < OTH	-> true

------------------------------------------------------------------
[0;1m--> SWAP(def, oth)[0m
DEF[0] = 'a', DEF[1] = 'g', 
OTH[0] = 'a', OTH[1] = 'b', OTH[2] = 'c', OTH[3] = 'd', OTH[4] = 'e', OTH[5] = 'f', 

------------------------------------------------------------------
[32;5;81m ----------------------------------------------------------------------
|                              STACK                                 |
----------------------------------------------------------------------
[0m

<<<<<<<<<<<<<<< ELEMENT_ACCESS && MODIFIERS >>>>>>>>>>>>>>>>>>>>>>[0m
[32;5;81m 
[0;1m--> .PUSH():[0m
[0;1m--> .TOP() && .POP():[0m
top is "fourth push"
top is "third  push"
top is "second push"
top is "first  push"

[32;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<<< CAPACITY >>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> EMPTY STACK:[0m
size()	= 0
empty()	= true

~pushed ints from 1 to 6
[0;1m--> FILLED STACK:[0m
size()	= 6
empty()	= false

[32;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<<< =OPERATOR >>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
assigning empty container to prev

[0;1m--> EMPTY:[0m
top is "6"
top is "5"
top is "4"
top is "3"
top is "2"
top is "1"

[32;5;81m <<<<<<<<<<<<<<<<<<<<<<<< NON_MEMBER FUNCITONS >>>>>>>>>>>>>>>>>>>>>>[0m
~ def with 1, 2, 3
~ oth with 11

[0;1m--> OPERATOR==()[0m
DEF == DEF	-> true
DEF == OTH	-> false

------------------------------------------------------------------
[0;1m--> OPERATOR!=()[0m
DEF != DEF	-> false
DEF != OTH	-> true

------------------------------------------------------------------
[0;1m--> OPERATOR<[0m
DEF < DEF	-> false
DEF < OTH	-> false
OTH > DEF	-> true

------------------------------------------------------------------

[35;5;81m------------------------------------------------------------------
|                                MAP                             |
------------------------------------------------------------------[0m
[35;5;81m
<<<<<<<<<<<<<<<<<<<<<<<<< CONSTRUCTORS >>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> EMPTY MAP:[0m
[0;1m--> COPIED MAP:[0m
[0;1m--> RANGE MAP:[0m
[35;5;81m
<<<<<<<<<<<<<<<<<<<<<<<<<< ITERATORS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1mDEFAULT:
[0m
[0;1mBEGIN() TO END()[0m
A, D, F, K, P, S, W, 
------------------------------------------------------------------
[0;1mRBEGIN() TO REND()[0m
W, S, P, K, F, D, A, 
------------------------------------------------------------------
[35;5;81m
<<<<<<<<<<<<<<<<<<<<<<<< ELEMENT ACCESS >>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m[] OPERATOR:				(inserts if not found)[0m
[0]: t	(previouseliy inserted)
[1]:  
[2]:  
[3]:  
[4]: k	(previousliy inserted)

------------------------------------------------------------------

------------------------------------------------------------------
[0;1mAT():					(throws when not found))[0m
at(2)  
at(10) CATCHED EXCEPTION: ft::map::at key not found
[35;5;81m
<<<<<<<<<<<<<<<<<<<<<<<< MODIFIERS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1mDEFAULT:
[0m
[0;1mCLEAR()[0m
[0;1mINSERT(ft::pair('l', true))			(single element)[0m
[0;1mINSERT(def.begin(), def.end())			(range)[0m
[0;1mERASE('l')					(single element, compare object could throw exeptions)[0m
[0;1mERASE(begin())					(single element)[0m
[0;1mERASE(++begin(); end())				(range)[0m

[0;1mSWAP(def)[0m
other:
default:
[35;5;81m
<<<<<<<<<<<<<<<<<<<<<<<<<< LOOKUP >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1mDEFAULT:
[0m
[0;1mCOUNT(), Amount of times key is found[0m
key found     = 1
key not found = 0

------------------------------------------------------------------
[0;1mLOWER_BOUND()[0m
Iterator pointing to the first element that is not less than
key(3) :3
key(5) :7

------------------------------------------------------------------
[0;1mUPPER_BOUND()[0m
Iterator pointing to the first element that is greater than
key(3) :7
key(5) :7

------------------------------------------------------------------
[0;1mEQUAL_RANGE()[0m
returns a pair, first element that is not less than key and another pointing to the first element greater than key
key(3) :3, 7
key(5) :7, 7
[35;5;81m
<<<<<<<<<<<<<<<<<<<<<<<<< TEST CONST >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
100
[35;5;81m
<<<<<<<<<<<<<<<<<<<<< OPERATOR OVERLOAD >>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
DEF == DEF	-> true
OTH == DEF	-> false

DEF < DEF	-> false
DEF < OTH	-> false
OTH < DEF	-> true

------------------------------------------------------------------
[35;5;81m
<<<<<<<<<<<<<<<<<<<<<<<<<< BIG SIZE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
