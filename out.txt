[38;5;81m 
<<<<<<<<<<<<<<<<<<<<<<<<< CONSTRUCTORS >>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> EMPTY VECTOR:[0m

------------------------------------------------------------------
[0;1m--> FILL VECTOR:[0m
FILL[0] = X, FILL[1] = X, FILL[2] = X, FILL[3] = X, FILL[4] = X, 
------------------------------------------------------------------
[0;1m--> RANGE VECTOR:	(fill.begin()+1, fill.end())[0m
RANGE[0] = X, RANGE[1] = X, RANGE[2] = X, RANGE[3] = X, 
------------------------------------------------------------------
[0;1m--> COPIED VECTOR:	(from fill)[0m
COPY[0] = X, COPY[1] = X, COPY[2] = X, COPY[3] = X, COPY[4] = X, 

[38;5;81m 
<<<<<<<<<<<<<<<<<<<<<<<<<<< ITERATORS >>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1mNO ITERATOR:[0m
for ( INT I = 0; I < SIZE; I++ ) :
0, 1, 2, 3, 4, 

[0;1mINCREMENT ITERATOR:[0m
for ( it = VEC.BEGIN(); it != VEC.END(); ++IT ) :
0, 1, 2, 3, 4, 

[0;1mDECREMENT ITERATOR:[0m
for ( it = --VEC.END(); it != --VEC.BEGIN(); --IT ) :
4, 3, 2, 1, 0, 

[0;1mINCREMENT REVERSE ITERATOR:[0m
for ( it = VEC.RBEGIN(); it != VEC.REND(); ++IT ) :
4, 3, 2, 1, 0, 

[0;1mDECREMENT REVERSE ITERATOR:[0m
for ( it = VEC.REND(); it != VEC.RBEGIN(); --IT ) :
0, 1, 2, 3, 4, 

[0;1m[] OPERATOR:				(forward iterator))[0m
it(vec.begin());       print it[3]: '3'
it(&vec[1]);           print it[3]: '4'

[0;1m[] OPERATOR:				(reverse iterator))[0m
it(vec.rbegin());       print it[3]: '1'
it(&vec[1]);           print it[3]: '0'


[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<<< CAPACITY >>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
D[0] = '!', D[1] = '!', D[2] = '!', D[3] = '!', D[4] = '!', 
size()     = 5
max_size() = 18446744073709551615
capacity() = 5
empty()    = false

------------------------------------------------------------------
[0;1m--> EMPTY VECTOR:
[0m
size()     = 0
max_size() = 18446744073709551615
capacity() = 0
empty()    = true

------------------------------------------------------------------
[0;1m--> RESIZE VECTOR:				
[0m
> resize to smaller size (2)
size()     = 2
capacity() = 5
RES[0] = '!', RES[1] = '!', 

> resize to bigger size 9, 'X')
size()     = 9
capacity() = 9
RES[0] = '!', RES[1] = '!', RES[2] = 'X', RES[3] = 'X', RES[4] = 'X', RES[5] = 'X', RES[6] = 'X', RES[7] = 'X', RES[8] = 'X', 

------------------------------------------------------------------
[0;1m--> RESERVE VECTOR:				(throws when requested capacity > max_size())
[0m
reserving 1000 for DEFAULT
size()     = 5
capacity() = 1000
RES[0] = '!', RES[1] = '!', RES[2] = '!', RES[3] = '!', RES[4] = '!', 

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<< ELEMENT ACCESS >>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
DEF[0] = "DEFAULT STRING"
DEF[1] = "DEFAULT STRING"
DEF[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> []OPERATOR:				(undefined behavior when out of bounds)
[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = "non default, used: mod[i]"
MOD[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .AT():				(throws when out of bounds)
[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = "non default, used: mod.at(i)"
MOD[2] = "DEFAULT STRING"


------------------------------------------------------------------
[0;1m--> .FRONT():				(undefined behavior when out of bounds)
[0m
MOD[0] == MOD.FRONT() is true
MOD[1] == MOD.FRONT() is false

------------------------------------------------------------------
[0;1m--> .BACK():				(undefined behavior when out of bounds)
[0m
MOD[2] == MOD.BACK() is true
MOD[1] == MOD.BACK() is false

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<< MODIFIERS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
DEF[0] = "DEFAULT STRING"
DEF[1] = "DEFAULT STRING"
DEF[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .CLEAR():[0m

------------------------------------------------------------------
[0;1m--> .ASSIGN(4, "assigned string"):			(fill version)[0m
FILL[0] = "assigned string (fill)"
FILL[1] = "assigned string (fill)"
FILL[2] = "assigned string (fill)"
FILL[3] = "assigned string (fill)"

------------------------------------------------------------------
[0;1m--> .ASSIGN(as.begin()+1, as.end()):			(range version)[0m
RANGE[0] = "DEFAULT STRING"
RANGE[1] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .PUSH_BACK("pushed string"):[0m
PUSH[0] = "DEFAULT STRING"
PUSH[1] = "DEFAULT STRING"
PUSH[2] = "DEFAULT STRING"
PUSH[3] = "pushed string"
PUSH[4] = "another pushed string"

------------------------------------------------------------------
[0;1m--> .POP_BACK():[0m
POP[0] = "DEFAULT STRING"
POP[1] = "DEFAULT STRING"
POP[2] = "DEFAULT STRING"
POP[3] = "pushed string"

------------------------------------------------------------------
[0;1m--> OTHER VECTOR:[0m
OTH[0] = "Other stuff"
OTH[1] = "Other stuff"

------------------------------------------------------------------
[0;1m--> .INSERT( .BEGIN()+1, "->inserted string"):				(one element)[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = " ------ inserted string"
MOD[2] = "DEFAULT STRING"
MOD[3] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .INSERT( .BEGIN(), 5,"->inserted string"):				(multible elements)[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = " ------ inserted string"
MOD[2] = " ------ inserted string"
MOD[3] = " ------ inserted string"
MOD[4] = " ------ inserted string"
MOD[5] = " ------ inserted string"
MOD[6] = "DEFAULT STRING"
MOD[7] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .INSERT(BEGIN()+1, OTHER.BEGIN(), OTHER.END()):			(range)[0m
MOD[0] = "DEFAULT STRING"
MOD[1] = "Other stuff"
MOD[2] = "Other stuff"
MOD[3] = "DEFAULT STRING"
MOD[4] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .ERASE(ERASE.BEGIN()+1)(from vector above):				(single element)[0m
returned iterator is "Other stuff"

MOD[0] = "DEFAULT STRING"
MOD[1] = "Other stuff"
MOD[2] = "DEFAULT STRING"
MOD[3] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .ERASE(ERASE.BEGIN()+2, ERASE.END()-1)(from same vector):				(range)[0m
returned iterator is "DEFAULT STRING"

MOD[0] = "DEFAULT STRING"
MOD[1] = "Other stuff"
MOD[2] = "DEFAULT STRING"

------------------------------------------------------------------
[0;1m--> .SWAP():				(swapping default && other)[0m
DEFAULT:
	DEF[0] = "Other stuff"
	DEF[1] = "Other stuff"
OTHER:
	OTH[0] = "DEFAULT STRING"
	OTH[1] = "DEFAULT STRING"
	OTH[2] = "DEFAULT STRING"

------------------------------------------------------------------

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<< NON-MEMBER FUNCTIONS >>>>>>>>>>>>>>>>>>>>>>[0m
[0;1m--> DEFAULT VECTOR:[0m
DEF[0] = 'a', DEF[1] = 'b', DEF[2] = 'c', DEF[3] = 'd', DEF[4] = 'e', DEF[5] = 'f', 

[0;1m--> OTHER VECTOR:[0m
OTH[0] = 'a', OTH[1] = 'b', 

------------------------------------------------------------------
[0;1m--> OPERATOR==()[0m
DEF == DEF	-> true
DEF == OTH	-> false

------------------------------------------------------------------
[0;1m--> OPERATOR!=()[0m
DEF != DEF	-> false
DEF != OTH	-> true

------------------------------------------------------------------
[0;1m--> OPERATOR<[0m
DEF < DEF	-> false
DEF < OTH	-> true

------------------------------------------------------------------
[0;1m--> SWAP(def, oth)[0m
DEF[0] = 'a', DEF[1] = 'g', 
OTH[0] = 'a', OTH[1] = 'b', OTH[2] = 'c', OTH[3] = 'd', OTH[4] = 'e', OTH[5] = 'f', 

------------------------------------------------------------------
[38;5;81m <<<<<<<<<<<<<<<<<<< LEXICOGRAPHICAL_COMPARE >>>>>>>>>>>>>>>>>>>>>>>[0m
true if the first range is lexicographically less than the second, otherwise false

Comparing foo (abc) and bar (abc):	false

Comparing foo (ab) and bar (abc):	true

Comparing foo (aXc) and bar (abc):	true

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<< EQUAL >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
true if the range [first1, last1) is equal to the range [first2, first2 + (last1 - first1)), otherwise false

Comparing foo "~<string>~~~~" and bar ".......<string>":	false

Comparing foo "<string>" and bar "<string>":			true

[38;5;81m <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< PAIR >>>>>>>>>>>>>>>>>>>>>>>>>>>>[0m
pair is a class template that provides a way to store two heterogeneous objects as a single unit

testing with string and double:

The price of lightbulbs is $0.99
The price of shoes is $39.9
The price of tomatoes is $2.3

